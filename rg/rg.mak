# Just to be sure that all will be the first rule...
# the 'real' all is in general_dep.mak
# Don't you ever use all: in any makefile you ever write or else...
all:

# In the source dir we only want to change to BUILDDIR
cd_to_builddir: $(CHECK_CONFIGURE)
ifdef MAKEFILE_DEBUG
	@echo "PWD_JPKG: $(PWD_JPKG)"
	@echo "PWD_BUILD: $(PWD_BUILD)"
	@echo "MAKECMDGOALS: $(MAKECMDGOALS)"
endif
	$(if $(filter /%,$(RGSRC)),,$(error Tree is not configured))
	umask 022 && \
	mkdir -p $(PWD_BUILD) $(if $(CONFIG_RG_JPKG),$(PWD_JPKG)) && \
	$(MAKE) -C $(PWD_BUILD) -f $(CURDIR)/Makefile \
	 $(MAKECMDGOALS) RGSRC=$(RGSRC)

distclean:
	rm -rf $(BUILDDIR) $(BUILDDIR_LINK)

check_configure:
	$(if $(wildcard $(CONFIGURATION_FILE)),,$(error Tree is not configured. Run make config))
	$(if $(wildcard $(CONFIG_STARTED_FILE)),$(error Tree did not complete configuration successfully. Run make config),)

export WARN2ERR

ifeq ($(WARN2ERR),)
  WARN2ERR=y
endif

ifeq ($(WARN2ERR),y)
  WARN2ERR_MARK=y
endif

ifdef WARN2ERR_MARK
  CFLAGS+=-Werror
  LOCAL_CFLAGS+=-Werror
  MOD_CFLAGS+=-Werror
endif

# This is a patch for linux kernel 2.4 until we will split its Makefile 
# (and arch/$(arch)/Makefile) into a Makefile and envir.mak
ifeq ($(CONFIG_RG_OS),LINUX_24)
  MODFLAGS+=-DMODULE
  RG_LINUX_CFLAGS+=-DKBUILD_BASENAME=$(@:%.o=%) 
endif

MOD_TARGET+=$(MOD_O_TARGET)
ifdef CONFIG_RG_UML
  ARCH_UML_DIR=$(BUILDDIR)/os/kernel/arch/um/
  UML_EXTRA_CFLAGS=-I$(ARCH_UML_DIR)/include/ -I$(ARCH_UML_DIR)/kernel/tt/include/ -I$(ARCH_UML_DIR)/kernel/skas/include/
endif
RG_LINUX_CFLAGS+=$(LINUX_CFLAGS) $(UML_EXTRA_CFLAGS)
IS_LOCAL_OBJ=$(strip $(foreach t,$(LOCAL_TARGETS),$(if $(filter $(notdir $1),$(notdir $(_O_OBJS_$t))),$t,)))
IS_SO_OBJ=$(strip $(foreach t,$(SO_TARGET),$(if $(filter $(notdir $1),$(notdir $(_O_OBJS_$t))),$t,)))
FIX_PIC_NAMES=$(if $(call IS_SO_OBJ,$1),$($(notdir 1):%_pic.o=%.o),$(notdir $1))
GET_MODULE=$(strip $(foreach m,$(MOD_TARGET),$(if $(filter $(notdir $1),$(notdir $(_O_OBJS_$m)) $(notdir $(OX_OBJS_$m))),$m,)))
IS_XOBJ=$(strip $(foreach m,$(MOD_TARGET),$(if $(filter $(notdir $1),$(notdir $(OX_OBJS_$m))),$m)))
ifdef CONFIG_RG_OS_LINUX
  GET_MODFLAGS=$(RG_LINUX_CFLAGS) $(MOD_CFLAGS) $(if $(filter $(call GET_MODULE,$1),$(MOD_2_STAT)),,$(MODFLAGS)) $(if $(call IS_XOBJ,$1),-DEXPORT_SYMTAB)
else
  GET_MODFLAGS=-D__KERNEL__ $(CFLAGS) $(MOD_CFLAGS)
endif

MOD_CFLAGS+=-I$(RGSRC)/pkg/include

GET_OBJ_CFLAGS_=$(if $(call IS_LOCAL_OBJ,$1),$(LOCAL_CFLAGS),$(if $(call GET_MODULE,$1),$(call GET_MODFLAGS,$1),$(CFLAGS))) $(TARGET_CFLAGS_$(call FIX_PIC_NAMES,$1)) $(CFLAGS_$(call FIX_PIC_NAMES,$1))

GET_OBJ_CFLAGS=$(call FIX_VPATH_CFLAGS,$(filter-out $(CFLAGS_REMOVE_$1),$(call GET_OBJ_CFLAGS_,$1)))

# Compilation functions for internal use only
# Usage: $(call RG_COMPILE_FUNC,EXTRA_FLAGS,output,src)
_RG_COMPILE_FUNC=$(if $(call IS_LOCAL_OBJ,$2),$(CC_FOR_BUILD),$(CC)) $1 $(call GET_OBJ_CFLAGS,$2) -c -o $2 $(filter-out $(PWD_SRC)/Makefile,$3) $(if $(STRIP_OBJS),&& $(STRIP) $(STRIP_FLAGS) $2)

# Autogenerated sources and links should not be exported nor their objects
DONT_EXPORT+=$(foreach f,$(LINKS) $(AUTOGEN_SRC),$f $(f:%.c=%.o) $(f:%.c=local_%.o) \
  $(f:%.c=%_pic.o))

# Distributin source files.
# This is the place to do keyword expansion, strip_ifdef, anything else?
RG_COMPILE_FUNC_JPKG_SRC=$(if $(filter $(DONT_EXPORT),$(notdir $1) $1),\
  echo "Not exporting SRC $1",$(RG_VPATH_CP) $1 \
  $(JPKG_CUR_DIR)/$(1:$(PWD_SRC)/%=%))

# this is the place to strip debug information
JPKG_SOURCES=$(EXPORT_AS_SRC) \
  $(filter %.c,$(call GET_FILE_FROM,$(EXPORT_HEADERS)))
ifndef CONFIG_RG_JPKG
  RG_COMPILE_FUNC=$(call _RG_COMPILE_FUNC,$1,$2,$3)
endif
ifdef CONFIG_RG_JPKG_SRC
  RG_COMPILE_FUNC=$(if $(JPKG_TARGET_$2),$(call _RG_COMPILE_FUNC,$1,$2,$3) &&) $(call RG_COMPILE_FUNC_JPKG_SRC,$3)
endif
ifdef CONFIG_RG_JPKG_BIN
  RG_COMPILE_FUNC=$(if $(JPKG_TARGET_$2),$(call _RG_COMPILE_FUNC,$1,$2,$3) &&)\
    $(if $(filter $(JPKG_SOURCES),$(notdir $3)),\
    $(call RG_COMPILE_FUNC_JPKG_SRC,$3),\
    $(if $(filter $(DONT_EXPORT),$2 $(2:local_%.o=%.o) $(2:%_pic.o=%.o)),\
    echo "Not exporting BIN $2",$(call _RG_COMPILE_FUNC,$1,$2,$3) && \
    $(RG_VPATH_CP) $2 $(JPKG_CUR_DIR)/$2.$(TARGET_MACHINE)))
endif

FILTER_SRC=$(filter %.c %.S %.s %.cpp %.cxx,$1)
RG_CXX_COMPILE_FUNC=$(CXX) $1 $(CXXFLAGS) $(call GET_OBJ_CFLAGS,$2) -c -o $2 $(filter-out $(PWD_SRC)/Makefile,$3) $(if $(STRIP_OBJS),&& $(STRIP) $(STRIP_FLAGS) $2)
ifdef VPATH
  GET_SRC=$(firstword $(wildcard $1.S) $(wildcard $(VPATH)/$1.S) \
    $(wildcard $1.cpp) $(wildcard $(VPATH)/$1.cpp) $(wildcard $1.cc) \
    $(wildcard $(VPATH)/$1.cc) $(wildcard $(VPATH)/$1.c) $(wildcard $1.c))
else
  GET_SRC=$(firstword $(wildcard $1.S) $(wildcard $1.cpp) $(wildcard $1.cc) \
    $(wildcard $1.c))
endif

SUBDIRS+=$(SUBDIRS_m)
SUBDIRS+=$(SUBDIRS_y)

ifdef CONFIG_RG_OS_VXWORKS
# For VxWorks we want MOD_TARGET to be compiled as O_TARGET
  O_TARGET+=$(MOD_TARGET)
endif

# *_SUBDIRS variables are using the mechanism in copy_db.mak
CLEAN_SUBDIRS?=$(SUBDIRS)
ARCHCONFIG_SUBDIRS?=$(SUBDIRS)
DOCS_SUBDIRS?=$(SUBDIRS)
RUN_UNITTESTS_SUBDIRS?=$(SUBDIRS)

DOCS_SUBDIRS_=$(DOCS_SUBDIRS:%=%/docs.subdir__)
CLEAN_SUBDIRS_=$(CLEAN_SUBDIRS:%=%/clean.subdir__)
ARCHCONFIG_SUBDIRS_=$(ARCHCONFIG_SUBDIRS:%=%/archconfig.subdir__)
RUN_UNITTESTS_SUBDIRS_=$(RUN_UNITTESTS_SUBDIRS:%=%/run_unittests.subdir__)
SUBDIRS_=$(SUBDIRS:%=%/all.subdir__)

ifdef CREATE_LOCAL
  LOCAL_TARGET+=$(foreach t,$(filter $(CREATE_LOCAL),$(TARGET)), \
    $(filter-out ./,$(dir $t))local_$(notdir $t))
  LOCAL_A_TARGET+=$(foreach t,$(filter $(CREATE_LOCAL),$(A_TARGET)), \
    $(filter-out ./,$(dir $t))$(patsubst lib%.a,liblocal_%.a,$(notdir $t)))
  LOCAL_O_TARGET+=$(foreach t,$(filter $(CREATE_LOCAL),$(O_TARGET)), \
    $(filter-out ./,$(dir $t))$(patsubst %.o,local_%.o,$(notdir $t)))
  COMMAND_FILE=variable.mak
  FOR_EACH=$(CREATE_LOCAL)
  INDEX_VARIABLE=$(if $(filter $(INDEX),$(TARGET)),O_OBJS_local_$(INDEX),O_OBJS_$(INDEX:lib%.a=liblocal_%.a))
  INDEX_VAL=$(if $(O_OBJS_$(INDEX)),$(O_OBJS_$(INDEX)),$(O_OBJS))
  include $(LOOP)
  FOR_EACH=$(CREATE_LOCAL)
  INDEX_VARIABLE=$(if $(filter $(INDEX),$(TARGET)),L_OBJS_local_$(INDEX),L_OBJS_$(INDEX:lib%.a=liblocal_%.a))
  INDEX_VAL=$(if $(L_OBJS_$(INDEX)),$(L_OBJS_$(INDEX)),$(L_OBJS))
  include $(LOOP)
endif

# Using _[OL]_OBJS_% as the internal variable of all objs for each target.
# This variable contain the real object names for compilation including local_
# prefix for local targets.
# User shouldn't use _O_OBJS or _L_OBJS directly!

FIXLOCALA=$(1:lib%=liblocal_%)
ISA=$(call EQ,.a,$(1:%.a=.a))
# Create _O_OBJS_% for any target either from the O_OBJS_% or the default
# O_OBJS
ADD_LOCAL_PREFIX=$(if $(filter $(INDEX),$(LOCAL_TARGETS)),$(foreach o,$1,$(dir $o)/$(if $(call ISA,$o),$(call FIXLOCALA,$(notdir $o)),local_$(notdir $o))),$1)
COMMAND_FILE=variable.mak
FOR_EACH=$(ALL_TARGETS)
INDEX_VARIABLE=_O_OBJS_$(INDEX)
MY_O_OBJS=$(if $(O_OBJS_$(INDEX)),$(O_OBJS_$(INDEX)),$(O_OBJS))

# Fix problem of .// in the obj name. (x.c, ./x.c, .//x.c are different names)
INDEX_VAL_TMP2=$(call ADD_LOCAL_PREFIX,$(MY_O_OBJS))
INDEX_VAL_TMP1=$(INDEX_VAL_TMP2:.//%=%)
INDEX_VAL=$(INDEX_VAL_TMP1:./%=%)
include $(LOOP)

ifndef CONFIG_VALGRIND
  # Create _O_OBJS_%_pic
  COMMAND_FILE=variable.mak
  FOR_EACH=$(SO_TARGET)
  INDEX_VARIABLE=_O_OBJS_$(INDEX)
  MY_PIC_OBJS=$(if $(O_OBJS_$(INDEX)),$(O_OBJS_$(INDEX)),$(O_OBJS))
  INDEX_VAL=$(MY_PIC_OBJS:%.o=%_pic.o)
  include $(LOOP)
  FPIC_FLAG=-fpic
endif

# Create _L_OBJS_%
COMMAND_FILE=variable.mak
FOR_EACH=$(ALL_TARGETS)
INDEX_VARIABLE=_L_OBJS_$(INDEX)
MY_L_OBJS=$(if $(L_OBJS_$(INDEX)),$(L_OBJS_$(INDEX)),$(L_OBJS))
INDEX_VAL=$(call ADD_LOCAL_PREFIX,$(MY_L_OBJS))
include $(LOOP)

# Create _OX_OBJS_% (for MOD_TARGET)
COMMAND_FILE=variable.mak
FOR_EACH=$(MOD_TARGET)
INDEX_VARIABLE=_OX_OBJS_$(INDEX)
INDEX_VAL=$(if $(OX_OBJS_$(INDEX)),$(OX_OBJS_$(INDEX)),$(OX_OBJS))
include $(LOOP)

_OTHER_OBJS=$(OTHER_OBJS)

# Create the TARGET_CFLAGS_% cflags. This variable is the CFLAGS_target of the
# target that %.o is connected to.
# Note that if the same object is used for more than one target the last 
# target CFLAGS will overrun the previes cflags.
COMMAND_FILE=target_cflags.mak
FOR_EACH=$(ALL_TARGETS)
include $(LOOP)

ifdef CONFIG_RG_OS_LINUX
  MOD_2_STAT_LINKS:=$(addprefix $(STATIC_MOD_DIR),$(MOD_2_STAT))
endif

JPKG_TARGETS_ALL:=$(strip $(DOING_MAKE_CONFIG) $(JPKG_TARGETS_ALL) \
  $(if $(CONFIG_RG_JPKG_BIN),$(JPKG_BIN_TARGETS_ALL)))
ifndef CONFIG_RG_JPKG
  JPKG_TARGETS_ALL:=y
endif

ifdef JPKG_TARGETS_ALL
  JPKG_TARGETS:=$(ALL_TARGETS) $(foreach t,$(A_TARGETS),__create_lib_$t)
else
  JPKG_TARGETS:=$(foreach t,$(ALL_TARGETS),$(if $(JPKG_TARGET_$t),$t)) \
    $(foreach t,$(A_TARGETS),$(if $(JPKG_TARGET_$t),__create_lib_$t))
  ifdef CONFIG_RG_JPKG_BIN
    JPKG_TARGETS:=$(foreach t,$(ALL_TARGETS),$(if $(JPKG_TARGET_BIN_$t),$t)) \
      $(foreach t,$(A_TARGETS),$(if $(JPKG_TARGET_BIN_$t),__create_lib_$t)) \
      $(JPKG_TARGETS)
  endif
endif

ifdef JPKG_TARGETS
  COMMAND_FILE=variable.mak
  FOR_EACH=$(JPKG_TARGETS)
  INDEX_VARIABLE=JPKG_TARGET_$(INDEX)
  INDEX_VAL=y
  include $(LOOP)
  COMMAND_FILE=jpkg_target.mak
  FOR_EACH=$(JPKG_TARGETS)
  INDEX_VAR_PREFIX=JPKG_TARGET_
  include $(LOOP)
endif

ifdef IS_BUILDDIR

# C source code compilation
%.o: %.c
	$(call RG_COMPILE_FUNC,,$@,$<)
	
# C++ source code compilation
%.o: %.cpp
	$(call RG_CXX_COMPILE_FUNC,,$@,$<)
%.o: %.cxx
	$(call RG_CXX_COMPILE_FUNC,,$@,$<)
%.o: %.cc
	$(call RG_CXX_COMPILE_FUNC,,$@,$<)

# PIC files
%_pic.o: %.c
	$(call RG_COMPILE_FUNC,$(FPIC_FLAG),$@,$<)

%_pic.o: %.cpp
	$(call RG_CXX_COMPILE_FUNC,$(FPIC_FLAG),$@,$<)

%_pic.o: %.cxx
	$(call RG_CXX_COMPILE_FUNC,$(FPIC_FLAG),$@,$<)

# For now assembly code compiles the same as C code
%.o: %.S
	$(call RG_COMPILE_FUNC,-D__ASSEMBLY__,$@,$<)

local_%.o : %.c
	$(call RG_COMPILE_FUNC,,$@,$<)

$(sO_OBJS):
	$(call RG_COMPILE_FUNC,$(sOFLAGS) -x assembler-with-cpp,$@,$<)

# This is a default rule to make an object out of its dependencies.
$(_OTHER_OBJS):
	$(call RG_COMPILE_FUNC,,$@,$(call FILTER_SRC,$^))

%.c: %.y
	$(YACC) $(YFLAGS) $< -o $@

$(O_TARGET):
	$(if $(JPKG_TARGET_$@),$(LD) $(ENDIAN_LDFLAGS) -r -o $@ $(foreach o,$(filter-out $(PWD_SRC)/Makefile,$^), $(call OS_PATH,$(o))) $(LDFLAGS_$@))

$(LOCAL_O_TARGET):
	$(if $(JPKG_TARGET_$@),$(HOST_LD) -r -o $@ $(foreach o,$(filter-out $(PWD_SRC)/Makefile,$^), $(call OS_PATH,$(o))) $(LDFLAGS_$@))

ifdef CONFIG_RG_OS_LINUX

$(MOD_TARGET):
	$(if $(JPKG_TARGET_$@),$(LD) $(ENDIAN_LDFLAGS) -r -o $@ $(filter-out $(*F).mod.c,$(filter-out %.h,$(filter-out $(PWD_SRC)/Makefile,$^))) $(if $(CONFIG_RG_OS_LINUX_26),$(if $(filter $@,$(MOD_2_STAT) $(MOD_O_TARGET)),,$(*F).mod.o)) $(LDFLAGS_$@))

$(MOD_2_STAT_LINKS):
	$(RG_LN) $(CURDIR)/$(notdir $@) $(dir $@)$(MOD_2_STAT_PREFIX_$(notdir $@))$(notdir $@)
endif

# TODO: Remove the __create_lib_ logic and replace it with a touch on the 
# changed object (make sure it is newer than the archive).
GET_AR=$(if $(filter $1,$(A_TARGET)),$(AR),$(if $(filter $1,$(LOCAL_A_TARGET)),$(HOST_AR),$(error RG_MAKEFILE internal error $1)))

$(foreach t,$(A_TARGETS),__create_lib_$t):
	$(if $(JPKG_TARGET_$@),\
	  $(if $?,$(call GET_AR,$(@:__create_lib_%=%)) cruv \
	  $(@:__create_lib_%=%) $?))

$(A_TARGET):
	$(if $(JPKG_TARGET_$@),$(RANLIB) $@)

$(LOCAL_A_TARGET):
	$(if $(JPKG_TARGET_$@),$(HOST_RANLIB) $@)

# Note: the -Wl,--no-whole-archive must be the last argument in order to make
# sure that when a so_target add -Wl,--whole-archive, it will not add all libgcc
# and libc into the sheared library

SO_LAST_FLAGS=-Wl,--no-whole-archive

$(SO_TARGET):
	$(if $(JPKG_TARGET_$@),\
	$(CC) -shared -o $@ $(FPIC_FLAG) $(SO_CFLAGS) $(SO_CFLAGS_$@) $^ \
	    $(call FIX_VPATH_LDFLAGS,$(SO_LDFLAGS) $(SO_LDFLAGS_$@)) \
	    $(SO_LAST_FLAGS),@echo "SO_TARGET: Not building ($@:$)")

# We have to have static on a local target so that the target will work in a 
# distribution tree on a different computer with different libc version.
$(LOCAL_TARGET):
	$(if $(JPKG_TARGET_$@),\
	$(CC_FOR_BUILD) -o $@ $^ $(call FIX_VPATH_LDFLAGS,\
	$(filter-out $(LDFLAGS_REMOVE_$@),\
	$(LOCAL_LDFLAGS)) $(LDFLAGS_$@)) $(filter-out $(LDLIBS_REMOVE_$@),\
	$(LOCAL_LDLIBS)) $(LDLIBS_$@),\
	@echo "LOCAL_TARGET: Not building ($@:$^)")

$(LOCAL_CXX_TARGET):
	$(if $(JPKG_TARGET_$@),\
	$(CXX_FOR_BUILD) -o $@ $^ $(call FIX_VPATH_LDFLAGS,\
	$(filter-out $(LDFLAGS_REMOVE_$@),$(LOCAL_LDFLAGS)) $(LDFLAGS_$@))\
	$(filter-out $(LDLIBS_REMOVE_$@),$(LOCAL_LDLIBS)) $(LDLIBS_$@),\
	@echo "LOCAL_CXX_TARGET: Not building ($@:$^)")

# This is the default binary distribution rule.
%.o: %.o.$(TARGET_MACHINE)
	$(MKDIR) $(dir $@)
	$(RG_LN) $(if $(filter /%,$<),,$(CURDIR)/)$< $@

include $(COPY_DB)

include $(RGSRC)/docs.mak

JPKG_EXPORTED_FILES+=$(call GET_FILE_FROM,$(EXPORT_HEADERS)) \
  $(CD_EXPORTED_FILES) $(LANG_FILES) $(foreach f,$(JPKG_EXPORTED_IF_EXIST),\
  $(if $(call VPATH_WILDCARD,$f),$f))
ifdef CONFIG_RG_JPKG_SRC
  JPKG_EXPORTED_FILES+=$(INTERNAL_HEADERS)
  JPKG_EXPORTED_DIR+=$(JPKG_EXPORTED_DIR_SRC)
endif

export_to_jpkg:
	@$(RG_SHELL_FUNCS) && \
	  $(foreach f,\
	  $(strip $(filter-out $(DONT_EXPORT),$(JPKG_EXPORTED_FILES))),\
	  rg_vpath_cp $f $(JPKG_CUR_DIR)/$f &&) true
ifneq ($(strip $(JPKG_EXPORTED_DIR)),)
	@rm -rf $(addprefix $(PWD_JPKG)/,$(strip $(JPKG_EXPORTED_DIR)))
	@$(RG_SHELL_FUNCS) && \
	  die() \
	  { \
	    echo "failed $$1" ; \
	    kill $$$$ ; \
	  } && \
	  cp_func() \
	  { \
	    rg_vpath_cp $$1 $$2 || die cp ; \
	  } && \
	  export -f rg_vpath_cp die cp_func && \
	  cd $(PWD_SRC) && \
	  find $(JPKG_EXPORTED_DIR) -not -regex '^\(\|.*/\)CVS/.*$$' \
	  $(foreach f,$(DONT_EXPORT),-and -not -name "$f") \
	    -and -type f \
	    -exec $(SHELL) -c "cp_func {} $(PWD_JPKG)/{}" ";"
endif

lang_lnk:
	$(foreach f,$(LANG_FILES), $(RG_LN) $(PWD_SRC)/$f \
	  $(BUILDDIR)/pkg/language/$(subst -,_,$(subst /,_,$(subst $(BUILDDIR)/,,$(CURDIR)/$f))).src &&) true

# This functions handles files in the format of <src>__<target>

# $1 - files in the <src>__<target> format
# $2 - 1 - return the src, 2 return the target
IS_FROM_TO=$(findstring __,$1)
GET_FILE_FROM_TO=$(foreach f,$1,$(if $(call IS_FROM_TO,$f),$(word $2,$(subst __, ,$f)),$f))
GET_FILE_FROM=$(call GET_FILE_FROM_TO,$1,1)
GET_FILE_TO=$(call GET_FILE_FROM_TO,$1,2)

# We create the target directory because it might not exist yet.
# We check wether to create the link to the SRC or the BUILD dir, usualy the
# target of the link is in the source directory, but autogenarated files are in
# BUILD directory.
EXPORT_FILE=$(MKDIR) $(dir $2) && \
  $(RG_LN) $(if $(wildcard $(PWD_SRC)/$1),$(PWD_SRC),$(CURDIR))/$1 $2

export_headers:
	$(foreach f,$(EXPORT_HEADERS),\
	$(call EXPORT_FILE,$(call GET_FILE_FROM,$f),$(RG_INCLUDE_DIR)/$(EXPORT_HEADERS_DIR)/$(call GET_FILE_TO,$f)) &&) true
	
export_libs:
ifdef EXPORT_LIBS
	$(foreach f,$(EXPORT_LIBS),$(call EXPORT_FILE,$f,$(BUILDDIR)/pkg/lib/$f) &&) true
endif
	
archconfig:: $(ARCHCONFIG_FIRST_TASKS) \
    $(if $(CONFIG_RG_JPKG_SRC),,export_headers export_libs) \
    $(ARCHCONFIG_SUBDIRS_) lang_lnk $(ARCHCONFIG_LAST_TASKS)

# One day we'll remove archconfig, until then...
config: archconfig

ALL_CLEAN_FILES=$(CLEAN) $(ALL_OBJS) $(ALL_PRODS) *.d

ifeq ($(CONFIG_BINFMT_FLAT),y)
  ALL_CLEAN_FILES+=$(foreach t,$(TARGET),$t.elf.o) $(foreach t,$(TARGET),$t.gdb.o) $(FAST_RAM_OBJS) $(FAST_RAM_OBJS:%.fr=%.o)
endif

ALL_CLEAN_FILES:=$(filter-out $(NOT_FOR_CLEAN),$(ALL_CLEAN_FILES))

clean:: $(FIRST_CLEAN) $(CLEAN_SUBDIRS_) do_clean

do_clean:
	rm -rf $(ALL_CLEAN_FILES)

RUN_UNITTEST_CMD=$(foreach t,$(RUN_UNITTEST),$(UNITTEST_SPAWNER) ./local_$(t) &&) true

run_unittests: $(RUN_UNITTESTS_SUBDIRS_)
	$(if $(RUN_UNITTEST_DATA),$(RG_LN) $(addprefix $(PWD_SRC)/,$(RUN_UNITTEST_DATA)) .)
	$(if $(RUN_UNITTEST),$(RUN_UNITTEST_CMD))

run_tests: run_unittests

# All dependencies including all: Are in general_dep.mak
include $(RGSRC)/general_dep.mak

else # IS_BUILDDIR
# do not use default rules, so that we do not generate by mistake any output
# into the source directory (the non BUILDDIR directory).
# like running "make --no-builtin-rules" 
.SUFFIXES:

endif # IS_BUILDDIR

.PHONY: do_clean lang_lnk cd_to_builddir
